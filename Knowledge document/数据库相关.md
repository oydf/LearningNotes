# 关系型和非关系型数据库的区别（各自优点）
    关系型数据库：
        特性：
            1、关系型数据库，是指采用了关系模型来组织数据的数据库；
            2、关系型数据库的最大特点就是事务的一致性；
            3、简单来说，关系模型指的就是二维表格模型，而一个关系型数据库就是由二维表及其之间的联系所组成的一个数据组织。
        优点：
            1、容易理解：二维表结构是非常贴近逻辑世界一个概念，关系模型相对网状、层次等其他模型来说更容易理解；
            2、使用方便：通用的SQL语言使得操作关系型数据库非常方便；
            3、易于维护：丰富的完整性(实体完整性、参照完整性和用户定义的完整性)大大减低了数据冗余和数据不一致的概率；
            4、支持SQL，可用于复杂的查询。
        缺点：
            1、为了维护一致性所付出的巨大代价就是其读写性能比较差；
            2、固定的表结构，数据存储结构扩展性差；
            3、海量数据的读写效率低下；
    
    非关系型数据库：
        特性：
            1、使用键值对存储数据；
            2、分布式；
            3、一般不支持ACID特性；
            4、非关系型数据库严格上不是一种数据库，应该是一种数据结构化存储方法的集合。
        优点：
            1、无需经过sql层的解析，读写性能很高；
            2、基于键值对，数据没有耦合性，容易扩展；
            3、存储数据的格式：nosql的存储格式是key,value形式、文档形式、图片形式等等，文档形式、图片形式等等，而关系型数据库则只支持基础类型。
        缺点：
            1、不提供sql支持，学习和使用成本较高；
            2、无事务处理，附加功能bi和报表等支持也不好；

# 常用SQL语句（DDL,DML,DCL,TCL）

# 数据库中join的类型与区别（inner join, outer join, cross join, natural join, self join），注意适用场景和sql语句的编写
    内连接：
        inner join(等值连接、内连接) 只返回两个表中连接字段相等的行。
    左连接：
        left join(左连接) 返回包括左表中的所有记录和右表中连接字段相等的记录 。
    右连接：
        right join(右连接) 返回包括右表中的所有记录和左表中连接字段相等的记录
    
    内连接、左连接、右连接的适用场景：相连接的两个表中必须在某个字段上有相等的值才可以将整条记录显示出来，如一条服务单记录在了两个表中，A表中记录了该服务单的服务时间、坐席名称和录音地址等基本信息，B表中记录了该服务单的业务详情，如保险单号，车牌号，保单日期等，当显示该服务单时，要将A表与B表做内连接，因为少这两表任何一个表，该服务单都不算完整，缺失的信息会使业务上没法继续。
    区别在于以哪张表为参照表。

    自然连接：
        自然连接只有在连接的列在两张表中的名称都相同时才会有用，其实，自然连接就是自动识别相同列的内连接
    外连接：
        完整外部联接返回左表和右表中的所有行。当某行在另一个表中没有匹配行时，则另一个表的选择列表列包含空值。如果表之间有匹配行，则整个结果集行包含基表的数据值。
    左外连接：
        左向外联接的结果集包括  LEFT OUTER子句中指定的左表的所有行，而不仅仅是联接列所匹配的行。如果左表的某行在右表中没有匹配行，则在相关联的结果集行中右表的所有选择列表列均为空值。   
    右外连接：
        右向外联接是左向外联接的反向联接。将返回右表的所有行。如果右表的某行在左表中没有匹配行，则将为左表返回空值。       
    自连接：
        自连接比较特殊，一般反映记录的上下级关系，例如员工线性表中会有一个字段，上级领导，这个字段对应的上级其实也是一个员工，这个员工信息就是通过自连接进行查找的。

    1、 查两表关联列相等的数据用内连接。
    2、 Col_L是Col_R的子集时用右外连接。
    3、 Col_R是Col_L的子集时用左外连接。
    4、 Col_R和Col_L彼此有交集但彼此互不为子集时候用全外。
    5、 求差操作的时候用联合查询。

# 数据库的索引类型
    非聚集索引：
        普通索引：这是最基本的索引，它没有任何限制，比如上文中为title字段创建的索引就是一个普通索引，MyIASM中默认的BTREE类型的索引，也是我们大多数情况下用到的索引。

        唯一索引：与普通索引类似，不同的就是：索引列的值必须唯一，但允许有空值（注意和主键不同）。如果是组合索引，则列值的组合必须唯一，创建方法和普通索引类似。

        组合索引：将多个字段建立到索引，比如建立 a b c的组合索引，会建立a_b_c a_b a三个索引，查询时从最左面的前缀开始查找。 
        备注：存在多个单列索引时，查询也只会用到最匹配的那一个索引。

        全文索引：FULLTEXT索引仅可用于 MyISAM 表；他们可以从CHAR、VARCHAR或TEXT列中作为CREATE TABLE语句的一部分被创建，或是随后使用ALTER TABLE 或CREATE INDEX被添加

    聚集索引：
        主键索引：它是一种特殊的唯一索引，不允许有空值。一般是在建表的时候同时创建主键索引。

# 聚集索引和非聚集索引的区别（叶节点存储内容）
    聚集索引（拼音字典）：
        数据记录的物理地址顺序与列值（一般是主键的那一列）的逻辑顺序相同，一个表中只能拥有一个聚集索引。
        比如：一张表主键为id,那么为id建立索引，id小的在物理地址低位，id大的在高位，如此排序。索引的叶子节点就是对应的数据节点，可以直接获取到对应的全部列的数据，而非聚集索引在索引没有覆盖到对应的列的时候需要进行二次查询，聚集索引的查询速度往往会更占优势。
    非聚集索引（偏旁字典）：
        该索引中索引的逻辑顺序与磁盘上行的物理存储顺序不同，一个表中可以拥有多个非聚集索引。
        非聚集索引叶节点仍然是索引节点，只是有一个指针指向对应的数据块，此如果使用非聚集索引查询，而查询列中包含了其他该索引没有覆盖的列，那么他还要进行第二次的查询，查询节点上对应的数据行的数据。

    使用以下语句进行查询，不需要进行二次查询，直接就可以从非聚集索引的节点里面就可以获取到查询列的数据。
    select id, username from t1 where username = '小明'
    select username from t1 where username = '小明'
    但是使用以下语句进行查询，就需要二次的查询去获取原数据行的score：
    select username, score from t1 where username = '小明'

    总结：
        使用聚集索引的查询效率要比非聚集索引的效率要高，但是如果需要频繁去改变聚集索引的值，写入性能并不高，因为需要移动对应数据的物理位置。
        非聚集索引在查询的时候可以的话就避免二次查询，这样性能会大幅提升。
        不是所有的表都适合建立索引，只有数据量大表才适合建立索引，且建立在选择性高的列上面性能会更好。


# 唯一性索引和主码索引的区别
    主键在表中有唯一标识的作用，不可重复，不能为空；
    当其它表建立外键关联当前表时，只可以关联主键。
    唯一索引，确切的说是唯一约束，是用来限制当前表插入时建立唯一约束的字段不可重复。
    一个是做为唯一标识，先唯一后标识；
    另一个是插入时做唯一限制。

# 索引的优缺点，什么时候使用索引，什么时候不能使用索引（重点）
    优点：
        唯一性索引，保证数据每一行的唯一性。
        加快数据的检索速度。
        加快表之间的连接。
        进行排序和分组时，索引能提高查询和排序效率。
        使用索引能使用数据sql优化器，提高性能。
    缺点：
        创建和维护索引都需要时间，并且随着数据量的增加而增加。
        每一个索引也要占据物理空间，随着数据量增大而增大。
        在更新数据的时候需要动态地维护索引，影响数据的更新性能。

    建议使用索引：
        经常搜索的字段上建立索引，加快检索速度。
        作为主键的字段建立索引，组织数据的排列结构。
        在经常需要根据范围进行搜索的列上创建索引，因为索引已经排序，其指定的范围是连续的； 
        在经常需要排序的列上创建索引，因为索引已经排序，这样查询可以利用索引的排序，加快排序查询时间； 
        在经常使用在WHERE子句中的列上面创建索引，加快条件的判断速度。
    不建议使用索引：
        查询中很少参考的字段。
        取值很少的字段，因为大量重复的值在索引中并不能提高检索速度。
        对于那些定义为text, image和bit数据类型的列不应该增加索引。这是因为，这些列的数据量要么相当大，要么取值很少。 
        需要频繁更新的字段不应该使用索引，因为更新性能与检索性能是矛盾的。

# 索引的底层实现（B+树，为何不采用红黑树，B树）
    B树索引：
        默认使用的索引，考虑到磁盘的Io性能，使用矮胖的平衡搜索树的效率远远高于瘦高的平衡树，索引选择b树而不用红黑树。
        磁盘读取是以块为最小单位的，比如一个块存储10条记录，有10000条记录，那么进行全表扫描需要读取1000个块，为某些列建立索引，假设一个块可以存储100条索引节点，那么索引节点的直接全索引扫描需要读取100个块，在此基础上，对索引使用红黑树排序，每个node使用一个块来存储，那么获取目标索引只需要扫描部分索引块，跟树的高度成正比。然后想办法降低平衡树的高度，及b树。
    哈希索引：
        散列索引是根据HASH算法构建的索引，所以检索速度很快，但不能范围查询。散列索引只适合等值查询，不适合模糊或范围查询。
    位图索引：
        如果用户查询的列的基数非常的小， 即只有的几个固定值，如性别、婚姻状况、行政区等等。要为这些基数值比较小的列建索引，就需要建立位图索引。

# B树和B+树具体实现
    b树的理解可以基于2-3树，在2-3树的基础上，多了一个特点，允许每个节点有M-1个子节点，及M阶B树。
        根节点至少有两个子节点
        每个节点有M-1个key，并且以升序排列
        位于M-1和M key的子节点的值位于M-1 和M key对应的Value之间
        其它节点至少有M/2个子节点
    b+树在b树的基础上做了改进。
        有k个子结点的结点必然有k个关键码；
        非叶结点仅具有索引作用，跟记录有关的信息均存放在叶结点中。
        树的所有叶结点构成一个有序链表，可以按照关键码排序的次序遍历全部记录。

# 索引最左前缀问题
    在一张表中有s1、s2、s3三个字段，建立这三个字段的组合索引，那么会有如下三个索引被建立：s1_s2_s3、s1_s2、s1，不能使用不包含最左前缀的索引：不能使用s2_s3。

# Mysql的优化（高频，索引优化，性能优化）


# 数据库引擎介绍，Innodb和Myisam的特点与区别
    插件式的存储引擎，方便在不同的业务场景下切换不同的存储引擎。
    主要区别：
        1).MyISAM是非事务安全型的，而InnoDB是事务安全型的。
        2).MyISAM锁的粒度是表级，而InnoDB支持行级锁定。
        3).MyISAM支持全文类型索引，而InnoDB不支持全文索引。
        4).MyISAM相对简单，所以在效率上要优于InnoDB，小型应用可以考虑使用MyISAM。
        5).MyISAM表是保存成文件的形式，在跨平台的数据转移中使用MyISAM存储会省去不少的麻烦。
        6).InnoDB表比MyISAM表更安全，可以在保证数据不会丢失的情况下，切换非事务表到事务表（alter table tablename type=innodb）。

    应用场景：
        1).MyISAM管理非事务表。它提供高速存储和检索，以及全文搜索能力。如果应用中需要执行大量的SELECT查询，那么MyISAM是更好的选择。
        2).InnoDB用于事务处理应用程序，具有众多特性，包括ACID事务支持。如果应用中需要执行大量的INSERT或UPDATE操作，则应该使用InnoDB，这样可以提高多用户并发操作的性能。

# 数据库中事务的ACID（四大特性都要能够举例说明，理解透彻，比如原子性和一致性的关联，隔离性不好会出现的问题）
    一组SQL语句组成的一个程序执行单元(Unit)，该执行单元要么成功Commit,要么失败Rollback。
    原子性：
        事务是一个不可分割的单元，事务中的流程要么都执行成功，要么都执行失败，不能只执行部分。比如银行存钱转钱，一个要存一部分钱，然后转账，必须这两件事都成功才能算转账成功，否则失败，退回到存钱之前。
    一致性：
        事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。 通俗的说：我和你的钱加起来一共是2000，那么不管我和你之间如何转账，转几次账，事务结束后我们的钱相加起来应该还得是2000，这就是事务的一致性。
    隔离性：
        多个事务并发访问时，事务之间是隔离的，一个事务不应该影响其它事务运行效果。 通俗的说：多个用户并发访问操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离。
    持久性：
        事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。 通俗的说：比如我将事务做完之后，这个结果是能持久下去的并能一直存下去。不管断电还是其他情况。

# 数据库隔离性设置不同会出现的问题（脏读、不可重复读、丢失修改、幻读）
    通常隔离级别越高，越能保证数据的完整性和一致性，但是对并发的效率就越低。一般情况下，采用读已提交或者可重复读，它能够有效避免脏读和不可重复读。

    脏写：（未提交读）（所有隔离级别都不允许）
        A事务写了一个数据项且尚未提交，B事务就更改该数据项提交，造成A事务的修改丢失。
    脏读：（已提交读）
        A事务更新了某数据项，B事务读取了该数据项，紧接着A再次对数据项进行了更新（或者回滚）。此时B事务读取的数据项就出现了异常。
    不可重复读：（可重复读）
        A事务读取（未作更新）了某数据项，B事务读取并更新了该数据项，B事务提交，接着A事务再次读取该数据项。此时A事务发生了异常。
    幻读：（可串行化）
        A事务查询了某表中所有符合条件的数据项，B事务在表中又插入了一条数据项且刚好符合A查询的条件并提交，接着A事务再次以同样标准查询该表，发现多了与上次结果不同，出现了幻象。此时A事务出现异常。

    隔离级别的前两个要求事务A一旦更新了数据项，事务B就不能对数据项进行更新操作，第一个级别个第二个级别的区别为要不要去事务A的更新操作进行提交。对于第三个级别，要求增加到了一旦事务A读取了数据项（未修改），事务B就不能更新了。第四个隔离级别要求数据库的调度必须保证可串行化即该调度产生的结果必须和某个串行调度保证一致性的结果。

# 数据库的范式
    第一范式：确保每列保持原子性
        第一范式的合理遵循需要根据系统的实际需求来定。比如某些数据库系统中需要用到“地址”这个属性，本来直接将“地址”属性设计成一个数据库表的字段就行。但是如果系统经常会访问“地址”属性中的“城市”部分，那么就非要将“地址”这个属性重新拆分为省份、城市、详细地址等多个部分进行存储，这样在对地址中某一部分操作的时候将非常方便。
    第二范式：确保表中的每列都和主键相关
        
    第三范式：确保每列都和主键列直接相关,而不是间接相关

    
数据的锁的种类，加锁的方式
视图的作用与使用方法（如何删除等）

# 存储过程
    存储过程是为了完成特定功能的SQL语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数(需要时)来调用执行。存储过程思想上很简单，就是数据库 SQL 语言层面的代码封装与重用。

# b+树索引与哈希索引的区别
    B+ Tree索引和Hash索引区别 哈希索引适合等值查询，也能进行范围查询 哈希索引没办法利用索引完成排序 哈希索引不支持多列联合索引的最左匹配规则 如果有大量重复键值得情况下，哈希索引的效率会很低，因为存在哈希碰撞问题

# 覆盖索引
    覆盖索引（covering index）指一个查询语句的执行只用从索引中就能够取得，不必从数据表中读取。也可以称之为实现了索引覆盖。 当一条查询语句符合覆盖索引条件时，MySQL只需要通过索引就可以返回查询所需要的数据，这样避免了查到索引后再返回表操作，减少I/O提高效率。 如，表covering_index_sample中有一个普通索引 idx_key1_key2(key1,key2)。当我们通过SQL语句：select key2 from covering_index_sample where key1 = ‘keytest’;的时候，就可以通过覆盖索引查询，无需回表。

# 索引下推
    5.6 MYSQL首先会返回符合zipcode='95054’的索引，然后根据lastname LIKE '%etrunia%'和address LIKE '%Main Street%'来判断索引是否符合条件。如果符合条件，则根据该索引来定位对应的数据，如果不符合，则直接reject掉。 有了索引下推优化，可以在有like条件查询的情况下，减少回表次数。

#  查询优化器
    一条SQL语句的查询，可以有不同的执行方案，至于最终选择哪种方案，需要通过优化器进行选择，选择执行成本最低的方案。 在一条单表查询语句真正执行之前，MySQL的查询优化器会找出执行该语句所有可能使用的方案，对比之后找出成本最低的方案。这个成本最低的方案就是所谓的执行计划。 优化过程大致如下： 1、根据搜索条件，找出所有可能使用的索引 2、计算全表扫描的代价 3、计算使用不同索引执行查询的代价 4、对比各种执行方案的代价，找出成本最低的那一个










































