# 指针和引用的区别和联系
    定义及性质区别
        1、指针是一个变量，其变量值存储内存地址，该内存地址可以寻址到一个存储单元，引用是一个变量的别名，跟原变量共享同一个存储单元；
        2、有const指针，没有const引用；
        3、指针可以有多级，引用只能有一级；
        4、指针的指向可以为空，引用必须初始化且不能为空；
        5、指针的值可以变换，引用的值不能变换；
        6、sizeof（指针）= 指针大小，4字节，sizeof（引用）=存储单元值的大小；
        7、指针和引用的自增运算意义不同，指针是移动步长，引用是值运算。

    函数参数传递的区别
        1、传引用和传指针看上去的效果一样，但本质不同：传指针实际上是值传递，将地址传入函数拷贝到局部变量，所以函数内部改变指针的指向不会影响到主调函数；引用传递是在函数内部声明了一个主调函数变量的别名，共享存储单元，在函数内对传参变量的操作跟主调原变量是一样的。
    
    引用和指针的联系
        引用是在编译的过程中被处理的，实际上就是在编译层面对程序员进行的一个比较友好的语法，而在实现上是由编译器完成了地址的传递：引用是一个指向其它对象的常量指针，它保存着所指对象的存储地址。并且使用的时候会自动解引用，而不需要像使用指针一样显式解引用。

# 堆和栈的区别
    内存中的堆栈：
        1、管理方式不同，栈内存由操作系统自动分配释放，堆内存由程序员手动申请释放，易内存泄漏；
        2、空间大小不同，每个进程的栈空间远远小于堆空间，栈默认1M,堆为虚拟内存大小；
        3、生长方向不同，堆向上生长，地址低到高，栈向下生长，地址高到低；
        4、分配方式不同，堆只有动态分配，栈有静态和动态（alloca函数）两种，都由操作系统自动释放；
        5、分配效率不同，栈由操作系统管理，在硬件层对栈提供支持，包括专门的栈寄存器和专门的CPU指令，效率很高，堆的实现机制很复杂，且易产生碎片，效率很低；
        6、存放内容不同，栈存放函数上下文环境、参数、局部变量等；堆存放内容由程序员控制。
        堆和栈相比，由于大量malloc()/free()或new/delete的使用，容易造成大量的内存碎片，并且可能引发用户态和核心态的切换，效率较低。栈相比于堆，在程序中应用较为广泛，最常见的是函数的调用过程由栈来实现，函数返回地址、EBP、实参和局部变量都采用栈的方式存放。虽然栈有众多的好处，但是由于和堆相比不是那么灵活，有时候分配大量的内存空间，主要还是用堆。

    数据结构中的堆栈：
        栈是一种先进先出的数据结构，只能操作栈顶元素。
        堆是一颗完全二叉树，所有节点值不大于或者不小于其父节点的值。

# new和delete是如何实现的，new 与 malloc，delete与free的异同处
    都可用于动态内存申请和释放

    new的实现：
        简单数据类型：直接调用系统全局函数operater new（）分配内存，分配失败则抛出异常，operater函数中使用malloc函数分配内存。
        复杂数据类型：调用系统全局函数operater new（）分配内存，分配失败则抛出异常，成功则在分配的内存上执行构造函数。
    new T[N]实现：
        调用operater new[]函数（调用N次operater new函数完成N个空间申请，在N个空间执行N次构造函数）
    
    delete的实现：
        简单数据类型：调用operater delete函数，底层调用free函数。
        复杂数据类型：先调用析构函数，在调用operater delete函数。
    delete[]的实现：
        在释放的对象空间上执行N次析构函数，完成N个对象中资源的清理，调用operator delete[]释放空间，实际在operator delete[]中调用N次operator delete来释放空间。

    区别：
        1、malloc和free是库函数，new和delete是运算符。对于非内部数据类型，需要构造析构，只能使用new和delete。
        2、malloc申请内存显式的制定长度，返回void*类型，需要显式的进行类型转换。
        3、new内置了sizeof、类型转换和类型安全检查
            new自动计算需要分配的空间，malloc手动指定；
            new是类型安全（编译时指出错误）的，malloc不安全；
            operater new可重载，用户能自定义内存分配策略，malloc不能；
            new和delete无需头文件支持，malloc和free需要库文件支持
    本质区别
        malloc/free是C/C++语言的标准库函数，new/delete是C++的运算符。
        对于用户自定义的对象而言，用maloc/free无法满足动态管理对象的要求。对象在创建的同时要自动执行构造函数，对象在消亡之前要自动执行析构函数。由于malloc/free是库函数而不是运算符，不在编译器控制权限之内，不能够把执行构造函数和析构函数的任务强加于malloc/free。因此C++需要一个能完成动态内存分配和初始化工作的运算符new，以及一个能完成清理与释放内存工作的运算符delete。

    联系
        既然new/delete的功能完全覆盖了malloc/free，为什么C++还保留malloc/free呢？因为C++程序经常要调用C函数，而C程序只能用malloc/free管理动态内存。如果用free释放“new创建的动态对象”，那么该对象因无法执行析构函数而可能导致程序出错。如果用delete释放“malloc申请的动态内存”，理论上讲程序不会出错，但是该程序的可读性很差。所以new/delete、malloc/free必须配对使用。

# C和C++的区别
    c语言是面向过程的编程语言，c++是从c语言扩展而来的一种面向对象的编程语言，c语言是c++的子集。两者的区别主要有：
        1、c++函数重载
        2、c++支持函数参数的引用传递
        3、函数的声明与调用，c++必须先声明再调用
        4、c++支持模板技术
        5、c++中，struct 和 class只有默认的成员变量作用域不同，一个是public，另一个是private，然后其他没有区别；C语言中struct不允许定义方法。
        6、c++支持面向对象特性。
        7、内存管理，c++有new和delete。
        8、c语言中const本质是常变量，c++中是常量

# Struct和class的区别
    1、默认继承权限不同，class继承默认是private继承，而struct默认是public继承
    2、class还可用于定义模板参数，像typename，但是关键字struct不能同于定义模板参数

    C++保留struct关键字，原因：
        保证与C语言的向下兼容性，C++必须提供一个struct；
        C++中的struct定义必须百分百地保证与C语言中的struct的向下兼容性，把C++中的最基本的对象单元规定为class而不是struct，就是为了避免各种兼容性要求的限制；
        对struct定义的扩展使C语言的代码能够更容易的被移植到C++中。

# define 和 const的区别（编译阶段、安全性、内存占用等）
    1、define在编译的预处理阶段替换常量，无法参与调试；const在编译和运行阶段起作用，可以调试。
    2、define只是简单的字符串替换，没有类型安全检查；const有数据类型，有类型安全检查。
    3、define在所有使用的地放展开替换，宏常量将在内存中有多个备份；const常量存储在常量区且只有一个备份。

# const在c和c++中的区别
    C语言：const定义的变量叫做常变量，不能直接修改变量值，但是会分配内存空间，通过指针可以去修改内容。
    c++：const定义一个常量，必须初始化，将初始化值放在符号表中，是否分配内存要看具体情况，无论分配内存与否，编译器都是从符号表读取常量值，跟内存空间无关（常量折叠）。
        
# 在C++中const和static的用法（定义，用途）
    const总结
        1、修饰变量：向编译器和程序员声明，const修饰的变量或对象的初始化的值是不能被修改的。
        2、修饰指针：指针的指向不能变或者指针指向的值不能变。
        3、修饰参数：声明输入参数在函数内部不可以改变。
        4、修饰成员函数：常函数不能修改类属性的值。
        5、修饰成员函数的返回值：使其返回值不能为左值。
    
    static总结
        1、静态全局变量：在全局数据区分配内存，将全局变量的作用域限定到当前文件内可见
        2、静态局部变量：将局部变量的生命周期提升为整个程序的生命周期，在全局数据区分配内存，只能在函数内部可见。
        3、静态函数：将函数作用域限定到当前文件
        4、静态数据成员：在类中声明，类外实例化，在全局数据区分配内存，只保存一份，类实例共享，且生命周期与程序生命周期一致。
        5、静态成员函数：不含this指针，为整个类服务，不可操作非静态成员。

# C++的顶层const和底层const
    const始终修饰离自己最近的一项（常量的指针、指针的常量）

# final和override关键字
    final：
        1、类名后加关键字final，防止该类被继承
        2、虚函数后加关键字final，防止虚函数被重写

    override：
        1、对于需要重写的虚函数，在重写的函数后加关键字override，显示声明覆盖父类虚函数，避免歧义，因为子类可以存在与基类中虚函数同名的函数，但通常为了避免歧义，不会选择使用同名函数。

# 复制初始化和直接初始化
    直接初始化：
        直接调用与实参匹配的构造函数。

    复制初始化：
        首先使用指定构造函数创建一个临时对象，然后用复制构造函数将临时对象复制到正在创建的对象。当复制构造函数被声明为私有时，所有的复制初始化都不能使用。

     两种分类方式：
    ​ 按参数分为： 有参构造和无参构造
    ​ 按类型分为： 普通构造和拷贝构造
     三种调用方式：括号法 显示法 隐式转换法

    编译器可能会对初始化语句进行优化，导致不同的结果，ClassTest ct2 = "ab";优化为ClassTest ct2（"ab"）；复制构造函数设置为private，编译器将不做优化，进而分辨出复制初始化。

    赋值操作：存在两个对象，将一个对象的值赋给另一个对象：检查自赋值、释放原有资源、申请新资源、返回本对象的引用。

# extern "C"的用法
    extern:
        extren const int m_val，告知编译器该变量在其他文件定义，在当前文件可用。
    
    extern “C”：
        1、告知编译器以C语言方式编译执行（兼容C代码）
        2、告知编译器不要使用函数重载机制（c++编译会将函数名进行符号添加），对于dll而言，阻隔掉因编译器类型不同，而造成的函数入口无法正确定位的问题。

# C++中的重载、重写和隐藏的区别
    重载：
        重载是指在同一个作用域下，函数的函数名相同，但是函数参数的个数，或者参数的类型，参数的顺序不同。这时函数之间就构成了重载关系。
    重写：
        重写也叫做覆盖，发生在父类和子类中，当父类中有虚函数时，在子类中重新定义一个与父类虚函数函数名，函数参数列表一模一样的函数，并重写函数的具体实现，此种情况就构成了重写。
    隐藏：
        隐藏也发生在父类和子类中，主要包含两种情况：
        　　1、子类和父类的函数名，参数类型完全相同，但是父类函数没有virtual关键字修饰
        　　2、子类和父类函数名相同，但是参数列表不同，此时不管有没有virtual关键字修饰，都能构成隐藏

# C++内存管理，内存池技术（热门问题），与csapp中几种内存分配方式对比学习加深理解
    c++本身的内存管理是通过new/delete或malloc/free管理的，当一个程序频繁使用这种方式进行内存分配和释放时，会在用户态和内核态频繁切换，性能很低，另一方面可能造成大量的内存碎片，降低内存的利用率。所以大型程序都会根据程序本身的内存需求，定制自己的内存池，从内存池分配和释放内存，既不会产生内存碎片也不用用户态和内核态频繁切换，极大提高了效率。

    内存池原理：
        1、申请一块大内存
        2、将大内存分割成多块等长的小内存块，用链表连接
        3、每次内存分配从空闲链表中取一块内存，更新空闲链表
        4、每次释放内存将释放的块重新加入空闲链表
        5、当内存不足时，重新申请一大块内存，连在上一块内存
        6、采用预测模型进行内存的申请，block每次申请的大小*2

# 内存泄露的定义，如何检测与避免
    定义：
        应用程序分配某段内存后，由于某种原因导致程序失去了对这段内存的控制，造成这段内存自己不使用也无法分配出去，造成内存的浪费。（自己崩溃，其他程序崩溃）
        堆内存泄漏：内存分配出去未释放
        系统资源泄漏：分配系统资源未释放

    检测方法：
        1、boundschecker，运行时错误检测工具。调试debug版本，在内存泄漏时提示内存分配序号，根据内存分配序号定位到该内存的分配语句，综合分析泄漏原因。
    
    避免方法：
        智能指针：智能指针是一个类，用来存储指向动态分配对象的指针，负责自动释放动态分配的对象，防止堆内存泄漏。动态分配的资源，交给一个类对象去管理，当类对象声明周期结束时，自动调用析构函数释放资源。

        1、shared_ptr:
            采用引用计数器的方法，允许多个智能指针指向同一个对象，每当多一个指针指向该对象时，指向该对象的所有智能指针内部的引用计数加1，每当减少一个智能指针指向对象时，引用计数会减1，当计数为0的时候会自动的释放动态分配的资源。 
            1) 智能指针将一个计数器与类指向的对象相关联，引用计数器跟踪共有多少个类对象共享同一指针；

             2) 每次创建类的新对象时，初始化指针并将引用计数置为1；

             3) 当对象作为另一对象的副本而创建时，拷贝构造函数拷贝指针并增加与之相应的引用计数；

             4) 对一个对象进行赋值时，赋值操作符减少左操作数所指对象的引用计数（如果引用计数为减至0，则删除对象），并增加右操作数所指对象的引用计数；

             5) 调用析构函数时，构造函数减少引用计数（如果引用计数减至0，则删除基础对象）。

        2、unique_ptr:
             unique_ptr采用的是独享所有权语义，一个非空的unique_ptr总是拥有它所指向的资源。转移一个unique_ptr将会把所有权全部从源指针转移给目标指针，源指针被置空；所以unique_ptr不支持普通的拷贝和赋值操作，不能直接用（移动构造）在STL标准容器中；
        
        3、weak_ptr:
             弱引用。 引用计数有一个问题就是互相引用形成环（环形引用），这样两个指针指向的内存都无法释放。需要使用weak_ptr打破环形引用。weak_ptr是一个弱引用，它是为了配合shared_ptr而引入的一种智能指针，它指向一个由shared_ptr管理的对象而不影响所指对象的生命周期，也就是说，它只引用，不计数。如果一块内存被shared_ptr和weak_ptr同时引用，当所有shared_ptr析构了之后，不管还有没有weak_ptr引用该内存，内存也会被释放。所以weak_ptr不保证它指向的内存一定是有效的，在使用之前使用函数lock()检查weak_ptr是否为空指针。
             将循环引用的一方该成弱引用，那么计数方式就不会出现1 1 而导致双方都无法释放资源。

        4、auto_ptr(被unique_ptr替代):
            1、避免因潜在的问题导致程序崩溃（unique在编译时报错，auto在运行时报错）因为auto_ptr有拷贝语义，拷贝后原象变得无效，再次访问原对象时会导致程序崩溃；unique_ptr则禁止了拷贝语义，但提供了移动语义，即可以使用std::move()进行控制权限的转移。

            2、unique_ptr可放在容器中，弥补了auto_ptr不能作为容器元素的缺点。

# 智能指针的循环引用
    在Man类内部会引用一个Woman，Woman类内部也引用一个Man。当一个man和一个woman是夫妻的时候，他们直接就存在了相互引用问题。man内部有个用于管理wife生命期的shared_ptr变量，也就是说wife必定是在husband去世之后才能去世。同样的，woman内部也有一个管理husband生命期的shared_ptr变量，也就是说husband必须在wife去世之后才能去世。这就是循环引用存在的问题：husband的生命期由wife的生命期决定，wife的生命期由husband的生命期决定，最后两人都死不掉，违反了自然规律，导致了内存泄漏。

# C++多态的实现
    就是程序运行时，父类指针可以根据具体指向的子类对象，来执行不同的函数，表现为多态。

    1、当类中存在虚函数时，编译器会在类中自动生成一张虚函数表
    2、虚函数表存储类虚成员函数指针
    3、虚函数表的生成和维护由编译器完成
    4、存在虚函数时，编译器为对象生成一个指向虚函数表的指针

# C++中类的数据成员和成员函数内存分布情况
    1、普通数据成员占用内存
    2、静态数据成员存储在静态存储区
    3、成员函数存储在代码段
    4、存在虚继承或虚函数时，对于指针占用内存

#this指针
    指向实例化对象本身，存储对象本身的地址，通过该地址访问对象内部成员变量。
    1、返回对象本身
    2、区别同名的形参与成员变量

#析构函数一般写成虚函数的原因
    在类存在多态继承的时候，如果析构函数不设置为虚函数，那么调用父类指针进行析构将只调用父类的析构函数，导致子类对象无法释放资源，造成内存泄漏。

#构造函数、拷贝构造函数和赋值操作符的区别
    构造函数：对象不存在，没用别的对象初始化
    拷贝构造函数：对象不存在，用别的对象初始化
    赋值运算符：对象存在，用别的对象给它赋值

#构造函数声明为explicit
    C++中， 一个参数的构造函数， 承担了两个角色。 1 是个构造器 2 是个默认且隐含的类型转换操作符。
    explicit构造函数只能被显示调用，不能隐式转换。

#构造函数为什么一般不定义为虚函数
    虚函数的意义在于：父类指针指向子类对象，通过父类指针调用具体子类对象的成员函数，但是构造函数是创建对象时自己主动调用，父类指针不可能通过子类对象调用子类的构造函数。

#构造函数的几种关键字(default delete 0)
    = default：程序员只需在函数声明后加上“=default;”，就可将该函数声明为 "=default"函数，编译器将为显式声明的 "=default"函数自动生成函数体。该函数比用户自己定义的默认构造函数获得更高的代码效率
    = delete：程序员只需在函数声明后上“=delete;”，就可将该函数禁用。
    = 0：将虚函数定义为纯虚函数（纯虚函数无需定义，= 0只能出现在类内部虚函数的声明语句处；当然，也可以为纯虚函数提供定义，不过函数体必须定义在类的外部）

#纯虚函数
    在基类中不能对虚函数给出有意义的实现，而把它声明为纯虚函数，它的实现留给该基类的派生类去做。这就是纯虚函数的作用。类似定义接口。

#静态类型和动态类型，静态绑定和动态绑定的介绍
    基类和派生类继承导致对象的指针和引用具有两种不同的类型：
        静态类型（编译期间）：
            指针声明时的类型
        动态类型（运行期间）：
            指针实际指向的类型

    静态绑定：绑定的是静态类型，所对应的函数或属性依赖于对象的静态类型，发生在编译期；
    动态绑定：绑定的是动态类型，所对应的函数或属性依赖于对象的动态类型，发生在运行期；

    一般的，virtual函数是动态绑定，non-virtual函数是静态绑定，缺省参数值也是静态绑定。 

#深拷贝和浅拷贝的区别（举例说明深拷贝的安全性）
    浅拷贝是将原始对象中的数据型字段拷贝到新对象中去，将引用型字段的“引用”复制到新对象中去，不把“引用的对象”复制进去，所以原始对象和新对象引用同一对象，新对象中的引用型字段发生变化会导致原始对象中的对应字段也发生变化。

    深拷贝是在引用方面不同，深拷贝就是创建一个新的和原始字段的内容相同的字段，是两个一样大的数据段，所以两者的引用是不同的，之后的新对象中的引用型字段发生改变，不会引起原始对象中的字段发生改变。

#介绍C++所有的构造函数
    默认构造函数和初始化构造函数在定义类的对象的时候，完成对象的初始化工作。
        （1）默认构造函数。以Student类为例，默认构造函数的原型为 
             Student(）；//没有参数 
        （2）初始化构造函数 
             Student(int num，int age）；//有参数 

    复制构造函数用于复制本类的对象
        （3）复制（拷贝）构造函数 
             Student(Student&）；//形参是本类对象的引用 

    转换构造函数用于将其他类型的变量，隐式转换为本类对象。
        （4）转换构造函数 
             Student(int r) ；//形参时其他类型变量，且只有一个形参

#什么情况下会调用拷贝构造函数（三种情况）
    1、将一个已存在的对象用复制的方法，建立一个新对象。
    2、函数的形参为类的对象时。（这点和普通类型的形参类似，要复制一份实参给函数）
    3、函数的返回值是类的对象，在函数中定义的对象，在函数结束后消息，需要调用复制构造函数，建立一个临时的对象，将该临时对象返回给调用该函数的对象。

#结构体内存对齐方式和为什么要进行内存对齐？
    1.平台原因(移植原因)：不是所有的硬件平台都能访问任意地址上的任意数据的；某些硬件平台只能在某些地址处取某些特定类型的数据，否则抛出硬件异常。 
    2.性能原因：数据结构(尤其是栈)应该尽可能地在自然边界上对齐。原因在于，为了访问未对齐的内存，处理器需要作两次内存访问；而对齐的内存访问仅需要一次访问。

    1、第一个成员在与结构体变量偏移量为0的地址
    2、其他成员变量要对齐到某个数字（对齐数）的整数倍的地址处。
    3、对齐数=编译器默认的一个对齐数 与 该成员大小的较小值。
        linux 中默认为4
        vs 中的默认值为8
    4、结构体总大小为最大对齐数的整数倍（每个成员变量除了第一个成员都有一个对齐数）

#手写智能指针的实现（shared_ptr和weak_ptr实现的区别）
    template<typename T>
    class Counter
    {
    private:
        //  数据成员
        T *ptr;    //  对象指针
        int cnt;   //  引用计数器
    
        //  友元类声明
        template<typename T>
        friend class SmartPtr;
    
        //  成员函数
        //  构造函数
        Counter(T *p)   //  p为指向动态分配对象的指针
        {
            ptr = p;
            cnt = 1;
        }
        //  析构函数
        ~Counter()
        {
            delete ptr;
        }
    };

    template<typename T>
    class SmartPtr
    {
    private:
        //  数据成员
        Counter<T> *ptr_cnt;  //  
    
    public:
    
        //  成员函数
        //  普通构造函数  初始化计数类
        SmartPtr(T *p)
        {
            ptr_cnt = new Counter<T>(p);
        }
        //  拷贝构造函数
        SmartPtr(const SmartPtr &other)
        {
            ptr_cnt = other.ptr_cnt;
            ptr_cnt->cnt++;
        }
        //  赋值运算符重载函数
        SmartPtr &operator=(const SmartPtr &rhs)
        {
            ptr_cnt = rhs->ptr_cnt;
            rhs.ptr_cnt->cnt++;
            ptr_cnt->cnt--;
            if (ptr_cnt->cnt == 0)
                delete ptr_cnt;
            return *this;
        }
        //  解引用运算符重载函数
        T &operator*()
        {
            return *(ptr_cnt->cnt);
        }
    
        //  析构函数
        ~SmartPtr()
        {
            ptr_cnt->cnt--;
            if (ptr_cnt->cnt == 0)
                delete ptr_cnt;
            else
                cout << "还有" << ptr_cnt->cnt << "个指针指向基础对象" << endl;
        }
    };

#遇到coredump要怎么调试
    ulimit -c返回0则表示生成core文件未开启，ulimit -c 文件大小开启
    gdb app core会自动跳转到段错误发生的地方，如果没有则用where命令跳转

#内存检查工具的了解
    valgrind
　　应用环境：Linux
　　编程语言：C/C++
　　使用方法：编译时加上-g选项，如 gcc -g filename.c  -o filename,使用如下命令检测内存使用情况：
　　结果输出：#valgrind --tool=memcheck --leak-check=yes --show-reachable=yes ./filename，就会看到内存使用报告
　　设计思路：根据软件的内存操作维护一个有效地址空间表和无效地址空间表（进程的地址空间）
　　优缺点：能够检测：
        使用未初始化的内存 (Use of uninitialised memory)
        使用已经释放了的内存 (Reading/writing memory after it has been free’d)
        使用超过 malloc分配的内存空间(Reading/writing off the end of malloc’d blocks)
        对堆栈的非法访问 (Reading/writing inappropriate areas on the stack)
        申请的空间是否有释放 (Memory leaks – where pointers to malloc’d blocks are lost forever)
        malloc/free/new/delete申请和释放内存的匹配(Mismatched use of malloc/new/new [] vs free/delete/delete [])
        src和dst的重叠(Overlapping src and dst pointers in memcpy() and related functions)
        重复free

#模板的用法与适用场景
    1、数据类型与算法相分离的泛型编程
        STL的大部分实现
    2、类型适配Traits
        借助于模板实现的，模板允许我们使用单一的泛型标记，来关联不同的特定行为：但这种关联是在编译期进行处理的，这些借助于模板的多态称为静多态 。萃取类消除编译不通过的情况。
    3、函数转发
        这使得我们可以通过模板类将函数指针以及它的参数类型记录下来，在需要的时候再对函数进行调用。
    4、元编程

#成员初始化列表的概念，为什么用成员初始化列表会快一些（性能优势）？
    概念：
        构造函数除了有名字，参数列表和函数体之外，还可以有初始化列表，初始化列表以冒号开头，后跟一系列以逗号分隔的初始化字段。
        C++初始化类成员的，它们是按照声明的顺序初始化的，而不是按照出现在初始化列表中的顺序。

    性能优势：
        内置数据类型：
            性能无差别

        类类型：
            1）如果使用类初始化列表，直接显式调用对应的构造函数即完成初始化 
            2）如果在构造函数中初始化，那么首先调用默认构造函数，然后调用指定的复制构造函数
            所以对于用户定义类型，使用列表初始化可以减少一次默认构造函数调用过程

    必须初始化：
        1、常量成员，因为常量只能初始化不能赋值，所以必须放在初始化列表里面
        2、引用类型，引用必须在定义的时候初始化，并且不能重新赋值，所以也要写在初始化列表里面
        3、没有默认构造函数的类类型，因为使用初始化列表可以不必调用默认构造函数来初始化，而是直接调用拷贝构造函数初始化。

#用过C++ 11吗，知道C++ 11哪些新特性？
    1、nullptr代替null（消除null=0引发的重载混乱）
    2、类型推导auto和decltype()
    3、基于范围的for循环（引用的使用方法）
    4、初始化列表（构造函数使用）
    5、模板增强（支持类型别名模板、支持默认模板参数）
    6、构造函数（委托构造、继承构造）
    7、lambda表达式
    8、新增容器（array、forword_list、unorder容器、tuple）
    9、语言级线程支持
    10、右值引用和move语义

#lambda表达式
    [函数对象参数] (操作符重载函数参数) mutable 或 exception 声明 -> 返回值类型 {函数体}

#C++的调用惯例（简单一点C++函数调用的压栈过程）
    假设有main函数、f1函数、f2函数，main调用f1,f1调用f2，从main函数开始执行，执行到f1的调用点时，首先系统将main函数的返回地址、参数、局部变量依次压入系统栈，然后开始执行f1函数，当执行到f2的调用点时，将f1的返回地址、参数和局部变量依次压栈，然后开始执行f2函数。当f2执行完毕，清理f2的函数栈，然后出栈，将f1的信息重新载入内存，执行f1函数，f1执行完毕，清理f1的函数栈，将main函数的信息出栈载入内存，继续执行，直到执行完毕。

#C++的四种强制转换
    static_cast：基本数据类型和关联类的相互转换（编译阶段）
    dynamic_cast：类对象的向下转换（父转子。一定有虚函数）（运行阶段）
    const_cast：它可以使一个本来不是const类型的数据转换成const类型的，或者把const属性去掉。（编译阶段）
    reinterpret_cast：它可以转化任何内置的数据类型为其他任何的数据类型，也可以转化任何指针类型为其他的类型。它甚至可以转化内置的数据类型为指针，无须考虑类型安全或者常量的情形。不到万不得已绝对不用。（编译阶段）

#C++中将临时变量作为返回值的时候的处理过程（栈上的内存分配、拷贝过程）
    临时变量存储在函数的栈内存中，当函数执行完毕，系统会修改栈顶指针，将局部变量出栈，但不改变内容，意味着该内存空间可以被分配出去，所以直接返回栈内存的内容是不对的，所以c++对于临时变量作为返回值，先将变量值保存在eax/edx/ax寄存器中，从寄存器返回值。

#C++的异常处理
    为了有效处理程序运行时错误：在程序执行过程中发现异常错误，不在此处立即处理，抛出该异常，让上层调用者处理该异常,沿着函数栈一直向上层抛出，一直到异常被处理，若main()还未处理则终止程序。try 块里面抛出哪种类型的异常，则catch里面捕获哪种类型的异常，自定义处理方法。

    try
    {
        throw 异常
    }catch()
    {

    }

    1、保证不在构造函数中抛出异常，因为构造函数的作用是构造对象并初始化，一旦抛出异常，有可能导致对象不完整或没有完全初始化。 
    2、保证不在析构函数中抛出异常，因为析构函数的作用是完成资源的清理，一旦抛出异常，有可能导致资源泄漏（内存泄漏等等）。

#volatile关键字
    C/C++编译器最基本优化原理：保证一段程序的输出，在优化前后无变化。

    1、易变的：下一条语句不会从上一条语句volatitle变量的寄存器读取值，而是从内存重新读取变量值；
    2、不可优化的：告诉编译器不要对变量进行激进的优化，甚至消除，确保程序员的的代码都会被执行；
    3、顺序的：能够保证Volatile变量间的顺序性，编译器不会进行乱序优化。Volatile变量与非Volatile变量的顺序，编译器不保证顺序，可能会进行乱序优化。同时，C/C++ Volatile关键词，并不能用于构建happens-before语义，因此在进行多线程程序设计时，要小心使用volatile，不要掉入volatile变量的使用陷阱之中。（通过锁机制构建happen-before语义）

#优化程序的几种方法
    1、尽量减少值传递，多用引用传递。
    2、++i的效率高于i++,i++会产生临时变量保存状态，然后自身自增，返回临时变量。
    3、避免循环代码过大：cache存储器速度最接近CPU，但是具有时间局部性和空间局部性，如果循环中代码过大，每次循环都会将cache更新，从内存中读入数据，导致效率降低。
    4、静态变量VS局部变量，局部变量存在与堆栈中，当堆栈内存多次被使用，将会被加入一级缓存，之后的程序使用该块内存访问速度很快。
    5、避免多重继承，偏移量计算寻址复杂
    6、少用dynamic_cast
    7、减少除法运算，计算机中除法实现比较复杂，是很慢的指令
    8、善用inline函数
    9、多用直接初始化

#public，protected和private访问权限和继承
    1、public：
        访问权限：类外可以直接访问public属性和方法
        继承：子类继承父类的属性和方法，不改变原权限
    
    2、protected：
        访问权限：类外不可直接访问，子类可访问protected属性和方法
        继承：子类继承父类的属性和方法，将public属性和方法改为protected权限

    3、private:
        访问权限：
            类外不可访问，子类也不能访问，只有类自身能访问
        继承：子类继承父类的属性和方法，将public和protected属性和方法改为private权限

#decltype()和auto
    1、auto：让编译器通过初始值来进行类型推演。从而获得定义变量的类型，所以说 auto 定义的变量必须有初始值；
    2、auto：会忽略引用，其次，auto一般会忽略掉顶层const，但底层const会被保留下来，顶层const需要手动声明；
    3、auto：无法从表达式和表达式作为返回类型的情况推演类型，所以引入decltype()；

    1、decltype只是为了推断出表达式的类型而不用这个表达式的值来初始化对象
    decltype(func()) sum = x; // sum的类型是函数func()的返回值的类型, 但是这时不会实际调用函数func()
    2、 不论是顶层const还是底层const, decltype都会保留。
    3、decltype（）不会忽略引用   
    
#inline和宏定义的区别
    1、内联函数在编译时展开替换，宏函数在预处理时展开替换；
    2、内联函数是真正的函数，有类型检查、语法判断等安全检查机制；宏函数只做文本替换；
    3、宏定义要注意括号的使用，容易引起歧义，内联函数跟普通函数一样定义即可；
    4、内联函数可以用作类成员函数，访问类属性，宏函数不可以；
    5、内联函数只是对编译器的一种建议，当函数体过长或者有循环将会被编译器当做普通函数处理。

#C++和C的类型安全
    类型安全：
        指不会试图访问不被授权的内存区域。

    C语言类型安全：
        只在局部上下文中表现类型安全，例如一个结构体指针访问其他结构体数据，编译器将报错，但是经过显式转换将不会报错，但可能存在内存访问越界问题。malloc函数返回void*指针，必须显式转换。

    c++的类型安全:
        1、空间申请new运算符返回严格匹配的对象类型；
        2、将void*类型转换为模板，通过模板的类型安全检查提供安全性；
        3、const关键字代替define的使用；
        4、inline代替define宏函数的使用；
        5、善用类型转换关键字static_cast,dynamic_cast，reinterpret_cast，const_cast。

#malloc实现原理
    brk/sbrk/mmap  三个系统调用（内存池原理）
    malloc在内核中维护了基地址指针和堆顶指针brk，基地址到堆顶的区域是已分配的内存，将内存划分为多个chunk,存储了chunk大小和分配信息，相近大小且空闲的chunk被连接成双向链表，一共维护了128个这样的链表，成为bins，每个链表的头指针维护在一个数组中，bins可以分为fast bin,unsorted bin （小块内存延迟释放，增加小内存的利用率），small bin 和large bin。程序每次动态分配内存时，先从fast bin 查找满足需求的chunk，不满足则到unsorted bin查找，不满足则去samll bin查找，不满足则去large bin查找，每次查找不满足都会将小的chunk合并成大的chunk。在这些空闲链表都找不到满足要求的内存块，则mmap映射一块新的内存，分配合适的大小给进程，剩下的部分加入空闲链表。若mmap映射也无法满足，则扩展堆顶，增加堆得大小，然后再mmap映射合适的内存。当前分配都是逻辑空间，当发生缺页异常时，才会真正映射到物理内存。

#free实现原理
    在malloc时记录了内存的状态信息，是否可用和大小，释放时只需传入指向该内存的指针，根据状态信息将内存使用状态置位空闲，由操作系统真正管理释放。
    释放逻辑：释放的内存是链表分配的时候，只有当空闲节点位于堆顶时，才会真正真正被系统回收，mmap申请的空间被释放是直接还给操作系统。

#c++虚函数表解析
    单一继承：
        在子类的内存布局中，编译器将生成虚函数表，虚函数表指针放在子类对象的起始位置，然后依次按照声明顺序放父类的非静态成员变量，最后按声明顺序放子类的非静态成员变量。在虚函数表中，按声明顺序存放父类虚函数的入口地址，子类虚函数入口地址，当子类重写父类虚函数时，在父类虚函数入口地址替换成子类虚函数入口地址，最后以null结尾或1，0.
    多重继承：
        多个虚基类，内个基类都有一张自己的虚函数表，在子类对象内存布局中，按照声明顺序存放父类的虚函数表，非静态成员变量，最后存放子类声明的非静态成员变量，子类未重写的虚函数只存放在第一张虚函数表中，重写的虚函数在每一张虚函数表中更新。
    虚继承：
        在子类中多分配一个虚基类表指针，虚基类表存放基类中重复的函数入口地址。

#this详解
    this 指针是一个隐含于每一个非静态成员函数中的特殊指针。它指向正在被该成员函数操作的那个对象。当对一个对象调用成员函数时，编译器先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时由隐含使用 this 指针。

#为什么会有this指针？
    第一、因为C++编译器G++是在GCC上优化而来，基本上是按照C语言的模式来编译程序，但C语言没有类等面向对象语言的特性，所以编译时将类当做 struct 类型；第二、C语言的函数都是全局的，而C++有成员函数，在编译C++程序时，也只能把类的非静态成员函数当成全局的函数对待，为了防止非当前类的其他对象调用，编译时添加了一个this常量指针，改指针为当前类类型，当对一个对象调用成员函数时，编译程序先将对象的地址赋给 this 指针，然后调用成员函数，每次成员函数存取数据成员时，由隐含使用 this 指针。

#内存越界访问内存会怎样
    内存越界读写，可能会导致未知的错误，当越界读可能读到是其他内存的值，当越界写可能写到其他内存，导致其他程序读到错误的值，这些都会产生未知的错误，但是，当越界写或者越界访问到保护地址，或者修改了函数栈入口等重要信息，或者违反指针的内存访问规则，就会产生中断，进而终止程序。

